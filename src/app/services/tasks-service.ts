import { inject, Injectable, OnDestroy } from '@angular/core';
import {
  collection,
  deleteDoc,
  doc,
  Firestore,
  onSnapshot,
  updateDoc,
  addDoc,
} from '@angular/fire/firestore';
import { SingleTask } from '../interfaces/single-task';
import { BehaviorSubject, Observable } from 'rxjs';
import { BreakpointObserver } from '@angular/cdk/layout';

@Injectable({
  providedIn: 'root',
})
export class TasksService implements OnDestroy {
  tasksDB: Firestore = inject(Firestore);
  breakpointObserver = inject(BreakpointObserver);

  tasks: SingleTask[] = [];
  /** Die aktuell im Dialog angezeigte Task (null = Dialog geschlossen). */
  activeTask: SingleTask | null = null;
  unsubTasks;
  smallView: boolean = false;

  private openAddTaskDialogSubject = new BehaviorSubject<boolean>(false);
  openAddTaskDialog$: Observable<boolean> = this.openAddTaskDialogSubject.asObservable();
  addTaskDialogIsOpen: boolean = false;

  constructor() {
    this.unsubTasks = this.subTasksArr();
    this.initBreakpointObserver();
  }

  private initBreakpointObserver(): void {
    this.breakpointObserver.observe(['(max-width:900px)']).subscribe((result) => {
      this.smallView = result.matches;
      this.openAddTaskDialogSubject.next(this.addTaskDialogIsOpen);
    });
  }

  setTaskObject(obj: any, id: string): SingleTask {
    return {
      id: id,
      status: obj.status || 'To do',
      title: obj.title,
      description: obj.description || '',
      dueDate: obj.dueDate,
      priority: obj.priority || 'Medium',
      assigned: obj.assigned || [],
      category: obj.category || 'User Story',
      subtasks: obj.subtasks || [],
      order: obj.order ?? 0,
    };
  }

  subTasksArr() {
    return onSnapshot(this.getTasksRef(), (arr) => {
      this.tasks = [];
      arr.forEach((element) => {
        this.tasks.push(this.setTaskObject(element.data(), element.id));
      });
      this.refreshActiveTask();
    });
  }

  /**
   * Aktualisiert die activeTask mit den neuesten Daten aus Firebase.
   * Wird nach jedem onSnapshot aufgerufen, damit der Dialog
   * immer aktuelle Daten zeigt (z.B. nach Subtask-Toggle).
   */
  private refreshActiveTask(): void {
    if (!this.activeTask?.id) return;
    const updated = this.tasks.find((t) => t.id === this.activeTask!.id);
    this.activeTask = updated || null;
  }

  getTasksRef() {
    return collection(this.tasksDB, 'tasks');
  }

  /**
   * Gibt die Referenz zu einem einzelnen Task-Dokument zurück.
   * Wird intern genutzt, um gezielt ein Dokument zu lesen oder zu ändern.
   * @param taskId - Die eindeutige Firebase-ID der Task
   * @returns Die Dokument-Referenz für diese Task
   */
  private getSingleTaskRef(taskId: string) {
    return doc(this.tasksDB, 'tasks', taskId);
  }

  /**
   * Aktualisiert den Status einer Task in Firebase.
   * Wird nach Drag & Drop aufgerufen, um den neuen Spaltenstatus zu speichern.
   * @param taskId - Die eindeutige Firebase-ID der Task
   * @param newStatus - Der neue Status ('To do', 'In progress', etc.)
   */
  async updateTaskStatus(taskId: string, newStatus: string): Promise<void> {
    const taskRef = this.getSingleTaskRef(taskId);
    await updateDoc(taskRef, { status: newStatus });
  }

  /**
   * Aktualisiert Status und Position mehrerer Tasks gleichzeitig.
   * Wird nach Drag & Drop aufgerufen, um die neue Reihenfolge zu speichern.
   * Jeder Task bekommt seinen Index als order-Wert (0, 1, 2, ...).
   * @param tasks - Die Tasks in ihrer neuen Reihenfolge
   * @param newStatus - Der Spalten-Status für alle Tasks in dieser Liste
   */
  async updateTaskPositions(tasks: SingleTask[], newStatus: string): Promise<void> {
    const updates = tasks.map((task, index) => this.updateSinglePosition(task, index, newStatus));
    await Promise.all(updates);
  }

  /**
   * Aktualisiert Status und Position einer einzelnen Task.
   * Wird intern von updateTaskPositions() aufgerufen.
   * @param task - Die zu aktualisierende Task
   * @param index - Die neue Position (0 = ganz oben)
   * @param newStatus - Der Spalten-Status
   */
  private async updateSinglePosition(
    task: SingleTask,
    index: number,
    newStatus: string,
  ): Promise<void> {
    if (!task.id) return;
    const taskRef = this.getSingleTaskRef(task.id);
    await updateDoc(taskRef, { status: newStatus, order: index });
  }

  /* ================================================================
   * Dialog-Steuerung
   * ================================================================ */

  /**
   * Öffnet den Task-Detail-Dialog für eine bestimmte Task.
   * @param taskId - Die ID der anzuzeigenden Task
   */
  openTaskDialog(taskId: string): void {
    this.activeTask = this.tasks.find((t) => t.id === taskId) || null;
  }

  /**
   * Schließt den Task-Detail-Dialog.
   * Setzt activeTask auf null – das @if im Template blendet den Dialog aus.
   */
  closeTaskDialog(): void {
    this.activeTask = null;
  }

  /**
   * Löscht eine Task endgültig aus Firebase.
   * @param taskId - Die ID der zu löschenden Task
   */
  async deleteTask(taskId: string): Promise<void> {
    const taskRef = this.getSingleTaskRef(taskId);
    await deleteDoc(taskRef);
  }

  /**
   * Aktualisiert den completed-Status eines Subtasks.
   * Liest die aktuelle Subtask-Liste, ändert den Ziel-Subtask,
   * und schreibt die gesamte Liste zurück nach Firebase.
   * @param taskId - Die ID der übergeordneten Task
   * @param subtaskId - Die ID des Subtasks
   * @param completed - Der neue Status (true/false)
   */
  async updateSubtaskStatus(taskId: string, subtaskId: string, completed: boolean): Promise<void> {
    const task = this.tasks.find((t) => t.id === taskId);
    if (!task?.subtasks) return;
    const updatedSubtasks = task.subtasks.map((st) =>
      st.id === subtaskId ? { ...st, completed } : st,
    );
    const taskRef = this.getSingleTaskRef(taskId);
    await updateDoc(taskRef, { subtasks: updatedSubtasks });
  }

  ngOnDestroy() {
    if (this.unsubTasks) this.unsubTasks();
  }

  openAddTaskDialog() {
    this.openAddTaskDialogSubject.next(true);
    this.addTaskDialogIsOpen = true;
  }

  closeAddTaskDialog() {
    this.openAddTaskDialogSubject.next(false);
    this.addTaskDialogIsOpen = false;
  }

  /**
   * Erstellt eine neue Task in Firebase
   * @param task - Die zu speichernde Task (ohne ID)
   * @returns Promise mit der erstellten Dokument-Referenz
   */
  async addTask(task: SingleTask): Promise<any> {
    try {
      // ID entfernen (wird von Firebase generiert)
      const { id, ...taskData } = task;

      // Neue Task ans Ende der 'To do' Spalte
      const todoTasks = this.tasks.filter((t) => t.status === 'To do');
      const newTask = {
        ...taskData,
        order: todoTasks.length, // Länge = nächster freier Index
        status: 'To do',
      };

      const docRef = await addDoc(this.getTasksRef(), newTask);
      console.log('Task added:', docRef.id);
      return docRef;
    } catch (error) {
      console.error('Error adding task:', error);
      throw error;
    }
  }
}
